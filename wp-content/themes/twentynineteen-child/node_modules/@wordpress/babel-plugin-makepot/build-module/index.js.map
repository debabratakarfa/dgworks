{"version":3,"sources":["/Users/riad/Workspace/a8c/gutenberg/packages/babel-plugin-makepot/src/index.js"],"names":["require","po","pick","reduce","uniq","forEach","sortBy","isEqual","merge","isEmpty","relative","sep","writeFileSync","DEFAULT_HEADERS","DEFAULT_FUNCTIONS","__","_n","_x","_nx","DEFAULT_OUTPUT","VALID_TRANSLATION_KEYS","REGEXP_TRANSLATOR_COMMENT","getNodeAsString","node","type","left","right","value","getTranslatorComment","path","_originalNodeLine","parent","parentPath","loc","start","line","comment","leadingComments","commentNode","end","match","split","map","text","trim","join","isValidTranslationKey","key","indexOf","isSameTranslation","a","b","module","exports","strings","nplurals","baseData","visitor","CallExpression","state","callee","name","property","functionKeys","opts","functions","translation","arguments","memo","arg","i","msgid","charset","headers","translations","msgstr","push","pluralsMatch","msgid_plural","Array","from","filename","file","pathname","comments","reference","translator","msgctxt","hasOwnProperty","Program","enter","exit","files","Object","keys","sort","context","sortedTranslations","data","compiled","compile","output","hasPendingWrite"],"mappings":"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","sourcesContent":["/**\n * Credits:\n *\n * babel-gettext-extractor\n * https://github.com/getsentry/babel-gettext-extractor\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2015 jruchaud\n * Copyright (c) 2015 Sentry\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/**\n * External dependencies\n */\n\nconst { po } = require( 'gettext-parser' );\nconst { pick, reduce, uniq, forEach, sortBy, isEqual, merge, isEmpty } = require( 'lodash' );\nconst { relative, sep } = require( 'path' );\nconst { writeFileSync } = require( 'fs' );\n\n/**\n * Default output headers if none specified in plugin options.\n *\n * @type {Object}\n */\nconst DEFAULT_HEADERS = {\n\t'content-type': 'text/plain; charset=UTF-8',\n\t'x-generator': 'babel-plugin-makepot',\n};\n\n/**\n * Default functions to parse if none specified in plugin options. Each key is\n * a CallExpression name (or member name) and the value an array corresponding\n * to translation key argument position.\n *\n * @type {Object}\n */\nconst DEFAULT_FUNCTIONS = {\n\t__: [ 'msgid' ],\n\t_n: [ 'msgid', 'msgid_plural' ],\n\t_x: [ 'msgid', 'msgctxt' ],\n\t_nx: [ 'msgid', 'msgid_plural', null, 'msgctxt' ],\n};\n\n/**\n * Default file output if none specified.\n *\n * @type {string}\n */\nconst DEFAULT_OUTPUT = 'gettext.pot';\n\n/**\n * Set of keys which are valid to be assigned into a translation object.\n *\n * @type {string[]}\n */\nconst VALID_TRANSLATION_KEYS = [ 'msgid', 'msgid_plural', 'msgctxt' ];\n\n/**\n * Regular expression matching translator comment value.\n *\n * @type {RegExp}\n */\nconst REGEXP_TRANSLATOR_COMMENT = /^\\s*translators:\\s*([\\s\\S]+)/im;\n\n/**\n * Given an argument node (or recursed node), attempts to return a string\n * represenation of that node's value.\n *\n * @param {Object} node AST node.\n *\n * @return {string} String value.\n */\nfunction getNodeAsString( node ) {\n\tswitch ( node.type ) {\n\t\tcase 'BinaryExpression':\n\t\t\treturn (\n\t\t\t\tgetNodeAsString( node.left ) +\n\t\t\t\tgetNodeAsString( node.right )\n\t\t\t);\n\n\t\tcase 'StringLiteral':\n\t\t\treturn node.value;\n\n\t\tdefault:\n\t\t\treturn '';\n\t}\n}\n\n/**\n * Returns translator comment for a given AST traversal path if one exists.\n *\n * @param {Object} path              Traversal path.\n * @param {number} _originalNodeLine Private: In recursion, line number of\n *                                     the original node passed.\n *\n * @return {?string} Translator comment.\n */\nfunction getTranslatorComment( path, _originalNodeLine ) {\n\tconst { node, parent, parentPath } = path;\n\n\t// Assign original node line so we can keep track in recursion whether a\n\t// matched comment or parent occurs on the same or previous line\n\tif ( ! _originalNodeLine ) {\n\t\t_originalNodeLine = node.loc.start.line;\n\t}\n\n\tlet comment;\n\tforEach( node.leadingComments, ( commentNode ) => {\n\t\tconst { line } = commentNode.loc.end;\n\t\tif ( line < _originalNodeLine - 1 || line > _originalNodeLine ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst match = commentNode.value.match( REGEXP_TRANSLATOR_COMMENT );\n\t\tif ( match ) {\n\t\t\t// Extract text from matched translator prefix\n\t\t\tcomment = match[ 1 ].split( '\\n' ).map( ( text ) => text.trim() ).join( ' ' );\n\n\t\t\t// False return indicates to Lodash to break iteration\n\t\t\treturn false;\n\t\t}\n\t} );\n\n\tif ( comment ) {\n\t\treturn comment;\n\t}\n\n\tif ( ! parent || ! parent.loc || ! parentPath ) {\n\t\treturn;\n\t}\n\n\t// Only recurse as long as parent node is on the same or previous line\n\tconst { line } = parent.loc.start;\n\tif ( line >= _originalNodeLine - 1 && line <= _originalNodeLine ) {\n\t\treturn getTranslatorComment( parentPath, _originalNodeLine );\n\t}\n}\n\n/**\n * Returns true if the specified key of a function is valid for assignment in\n * the translation object.\n *\n * @param {string} key Key to test.\n *\n * @return {boolean} Whether key is valid for assignment.\n */\nfunction isValidTranslationKey( key ) {\n\treturn -1 !== VALID_TRANSLATION_KEYS.indexOf( key );\n}\n\n/**\n * Given two translation objects, returns true if valid translation keys match,\n * or false otherwise.\n *\n * @param {Object} a First translation object.\n * @param {Object} b Second translation object.\n *\n * @return {boolean} Whether valid translation keys match.\n */\nfunction isSameTranslation( a, b ) {\n\treturn isEqual(\n\t\tpick( a, VALID_TRANSLATION_KEYS ),\n\t\tpick( b, VALID_TRANSLATION_KEYS )\n\t);\n}\n\nmodule.exports = function() {\n\tconst strings = {};\n\tlet nplurals = 2,\n\t\tbaseData;\n\n\treturn {\n\t\tvisitor: {\n\t\t\tCallExpression( path, state ) {\n\t\t\t\tconst { callee } = path.node;\n\n\t\t\t\t// Determine function name by direct invocation or property name\n\t\t\t\tlet name;\n\t\t\t\tif ( 'MemberExpression' === callee.type ) {\n\t\t\t\t\tname = callee.property.name;\n\t\t\t\t} else {\n\t\t\t\t\tname = callee.name;\n\t\t\t\t}\n\n\t\t\t\t// Skip unhandled functions\n\t\t\t\tconst functionKeys = ( state.opts.functions || DEFAULT_FUNCTIONS )[ name ];\n\t\t\t\tif ( ! functionKeys ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Assign translation keys by argument position\n\t\t\t\tconst translation = path.node.arguments.reduce( ( memo, arg, i ) => {\n\t\t\t\t\tconst key = functionKeys[ i ];\n\t\t\t\t\tif ( isValidTranslationKey( key ) ) {\n\t\t\t\t\t\tmemo[ key ] = getNodeAsString( arg );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn memo;\n\t\t\t\t}, {} );\n\n\t\t\t\t// Can only assign translation with usable msgid\n\t\t\t\tif ( ! translation.msgid ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// At this point we assume we'll save data, so initialize if\n\t\t\t\t// we haven't already\n\t\t\t\tif ( ! baseData ) {\n\t\t\t\t\tbaseData = {\n\t\t\t\t\t\tcharset: 'utf-8',\n\t\t\t\t\t\theaders: state.opts.headers || DEFAULT_HEADERS,\n\t\t\t\t\t\ttranslations: {\n\t\t\t\t\t\t\t'': {\n\t\t\t\t\t\t\t\t'': {\n\t\t\t\t\t\t\t\t\tmsgid: '',\n\t\t\t\t\t\t\t\t\tmsgstr: [],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\n\t\t\t\t\tfor ( const key in baseData.headers ) {\n\t\t\t\t\t\tbaseData.translations[ '' ][ '' ].msgstr.push( `${ key }: ${ baseData.headers[ key ] };\\n` );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Attempt to exract nplurals from header\n\t\t\t\t\tconst pluralsMatch = ( baseData.headers[ 'plural-forms' ] || '' ).match( /nplurals\\s*=\\s*(\\d+);/ );\n\t\t\t\t\tif ( pluralsMatch ) {\n\t\t\t\t\t\tnplurals = pluralsMatch[ 1 ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Create empty msgstr or array of empty msgstr by nplurals\n\t\t\t\tif ( translation.msgid_plural ) {\n\t\t\t\t\ttranslation.msgstr = Array.from( Array( nplurals ) ).map( () => '' );\n\t\t\t\t} else {\n\t\t\t\t\ttranslation.msgstr = '';\n\t\t\t\t}\n\n\t\t\t\t// Assign file reference comment, ensuring consistent pathname\n\t\t\t\t// reference between Win32 and POSIX\n\t\t\t\tconst { filename } = this.file.opts;\n\t\t\t\tconst pathname = relative( '.', filename ).split( sep ).join( '/' );\n\t\t\t\ttranslation.comments = {\n\t\t\t\t\treference: pathname + ':' + path.node.loc.start.line,\n\t\t\t\t};\n\n\t\t\t\t// If exists, also assign translator comment\n\t\t\t\tconst translator = getTranslatorComment( path );\n\t\t\t\tif ( translator ) {\n\t\t\t\t\ttranslation.comments.translator = translator;\n\t\t\t\t}\n\n\t\t\t\t// Create context grouping for translation if not yet exists\n\t\t\t\tconst { msgctxt = '', msgid } = translation;\n\t\t\t\tif ( ! strings[ filename ].hasOwnProperty( msgctxt ) ) {\n\t\t\t\t\tstrings[ filename ][ msgctxt ] = {};\n\t\t\t\t}\n\n\t\t\t\tstrings[ filename ][ msgctxt ][ msgid ] = translation;\n\t\t\t},\n\t\t\tProgram: {\n\t\t\t\tenter() {\n\t\t\t\t\tstrings[ this.file.opts.filename ] = {};\n\t\t\t\t},\n\t\t\t\texit( path, state ) {\n\t\t\t\t\tconst { filename } = this.file.opts;\n\t\t\t\t\tif ( isEmpty( strings[ filename ] ) ) {\n\t\t\t\t\t\tdelete strings[ filename ];\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Sort translations by filename for deterministic output\n\t\t\t\t\tconst files = Object.keys( strings ).sort();\n\n\t\t\t\t\t// Combine translations from each file grouped by context\n\t\t\t\t\tconst translations = reduce( files, ( memo, file ) => {\n\t\t\t\t\t\tfor ( const context in strings[ file ] ) {\n\t\t\t\t\t\t\t// Within the same file, sort translations by line\n\t\t\t\t\t\t\tconst sortedTranslations = sortBy(\n\t\t\t\t\t\t\t\tstrings[ file ][ context ],\n\t\t\t\t\t\t\t\t'comments.reference'\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tforEach( sortedTranslations, ( translation ) => {\n\t\t\t\t\t\t\t\tconst { msgctxt = '', msgid } = translation;\n\t\t\t\t\t\t\t\tif ( ! memo.hasOwnProperty( msgctxt ) ) {\n\t\t\t\t\t\t\t\t\tmemo[ msgctxt ] = {};\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Merge references if translation already exists\n\t\t\t\t\t\t\t\tif ( isSameTranslation( translation, memo[ msgctxt ][ msgid ] ) ) {\n\t\t\t\t\t\t\t\t\ttranslation.comments.reference = uniq( [\n\t\t\t\t\t\t\t\t\t\tmemo[ msgctxt ][ msgid ].comments.reference,\n\t\t\t\t\t\t\t\t\t\ttranslation.comments.reference,\n\t\t\t\t\t\t\t\t\t].join( '\\n' ).split( '\\n' ) ).join( '\\n' );\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tmemo[ msgctxt ][ msgid ] = translation;\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn memo;\n\t\t\t\t\t}, {} );\n\n\t\t\t\t\t// Merge translations from individual files into headers\n\t\t\t\t\tconst data = merge( {}, baseData, { translations } );\n\n\t\t\t\t\t// Ideally we could wait until Babel has finished parsing\n\t\t\t\t\t// all files or at least asynchronously write, but the\n\t\t\t\t\t// Babel loader doesn't expose these entry points and async\n\t\t\t\t\t// write may hit file lock (need queue).\n\t\t\t\t\tconst compiled = po.compile( data );\n\t\t\t\t\twriteFileSync( state.opts.output || DEFAULT_OUTPUT, compiled );\n\t\t\t\t\tthis.hasPendingWrite = false;\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t};\n};\n\nmodule.exports.getNodeAsString = getNodeAsString;\nmodule.exports.getTranslatorComment = getTranslatorComment;\nmodule.exports.isValidTranslationKey = isValidTranslationKey;\nmodule.exports.isSameTranslation = isSameTranslation;\n"]}